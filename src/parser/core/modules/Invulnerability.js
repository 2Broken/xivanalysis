import Module from 'parser/core/Module'
import {Item} from 'parser/core/modules/Timeline'

// Ms of inactivity before an enemy is considered invuln
const MIN_INVULN_INACTIVITY = 5000

export default class Invulnerability extends Module {
	static handle = 'invuln'
	static dependencies = [
		'timeline',
	]

	_invulns = {}

	constructor(...args) {
		super(...args)
		this.addHook('complete', this._onComplete)
	}

	// -----
	// Normaliser
	// -----
	normalise(events) {
		// Tracking all damage for full invuln, and non-tick damage for targetable
		// TODO: Work out how to track this better - currently relies on the person being parsed pressing buttons which isn't exactly the _best_ measure.
		const lastHit = {}

		const checkLastHits = (target, event) => {
			const enemyLastHits = lastHit[target] || {
				invulnerable: event.timestamp,
				untargetable: event.timestamp,
			}

			// Invuln
			checkForType(target, enemyLastHits, 'invulnerable', event)

			// Untargetable
			if (!event.tick) {
				checkForType(target, enemyLastHits, 'untargetable', event)
			}

			lastHit[target] = enemyLastHits
		}

		const checkForType = (target, lastHits, type, event) => {
			const last = lastHits[type]
			const timeSince = event.timestamp - last

			if (timeSince > MIN_INVULN_INACTIVITY) {
				this.getInvulns(target).push({
					type: type,
					start: last,
					end: event.timestamp,
				})
			}

			lastHits[type] = event.timestamp
		}

		for (let i = 0; i < events.length; i++) {
			const event = events[i]

			// Ignore non-damage events, and damage to friendlies
			if (
				event.type !== 'damage' ||
				event.targetIsFriendly ||
				!event.targetID
			) { continue }

			checkLastHits(event.targetID, event)
			checkLastHits('all', event)
		}

		// TODO: Do i want to add events too or nah
		return events
	}

	// -----
	// Event handlers
	// -----
	_onComplete() {
		const startTime = this.parser.fight.start_time

		// Add invulns to the timeline
		this.getInvulns().forEach(invuln => {
			this.timeline.addItem(new Item({
				type: 'background',
				start: invuln.start - startTime,
				end: invuln.end - startTime,
			}))
		})
	}

	// -----
	// Public API
	// -----
	isUntargetable = (
		targetId = 'all',
		time = this.parser.currentTimestamp
	) => this._checkInvuln(targetId, time, 'untargetable')
	isInvulnerable = (
		targetId = 'all',
		time = this.parser.currentTimestamp
	) => this._checkInvuln(targetId, time, 'invulnerable')

	getUntargetableUptime = (
		targetId = 'all',
		start = 0,
		end = this.parser.currentTimestamp
	) => this._getInvulnUptime(targetId, start, end, 'untargetable')
	getInvulnerableUptime = (
		targetId = 'all',
		start = 0,
		end = this.parser.currentTimestamp
	) => this._getInvulnUptime(targetId, start, end, 'invulnerable')

	getInvulns(targetId = 'all') {
		if (!this._invulns[targetId]) {
			this._invulns[targetId] = []
		}

		return this._invulns[targetId]
	}

	_getInvulnUptime(targetId, start, end, type) {
		return this.getInvulns(targetId)
			.filter(invuln => invuln.type === type)
			.reduce((uptime, invuln) => {
				if (invuln.end < start || invuln.start > end) { return uptime }
				return uptime + Math.min(invuln.end, end) - Math.max(invuln.start, start)
			}, 0)
	}

	_checkInvuln(targetId, time, type) {
		const filtered = this.getInvulns(targetId).filter(invuln =>
			invuln.type === type &&
			invuln.start <= time &&
			invuln.end >= time
		)

		return !!filtered.length
	}
}
