import Module from 'parser/core/Module'

// Ms of inactivity before an enemy is considered invuln
const MIN_INVULN_INACTIVITY = 5000

export default class Invulnerability extends Module {
	invulns = {}

	normalise(events) {
		// Tracking all damage for full invuln, and non-tick damage for targetable
		const lastHit = {}

		for (let i = 0; i < events.length; i++) {
			const event = events[i]

			// Ignore non-damage events, and damage to friendlies
			if (event.type !== 'damage' || event.targetIsFriendly) { continue }

			const enemyLastHits = lastHit[event.targetID] || {
				damage: event.timestamp,
				nonTick: event.timestamp
			}

			// Invuln
			const last = enemyLastHits.damage
			const timeSince = event.timestamp - last

			if (timeSince > MIN_INVULN_INACTIVITY) {
				this.getInvulns(event.targetID).push({
					type: 'invulnerable',
					start: last,
					end: event.timestamp
				})
			}

			enemyLastHits.damage = event.timestamp

			// Untargetable
			if (!event.tick) {
				const last = enemyLastHits.nonTick
				const timeSince = event.timestamp - last

				if (timeSince > MIN_INVULN_INACTIVITY) {
					this.getInvulns(event.targetID).push({
						type: 'untargetable',
						start: last,
						end: event.timestamp
					})
				}

				enemyLastHits.nonTick = event.timestamp
			}

			lastHit[event.targetID] = enemyLastHits
		}

		// TODO: Do i want to add events too or nah
		return events
	}

	isUntargetable = (targetId) => this._checkInvuln(targetId, 'untargetable')
	isInvulnerable = (targetId) => this._checkInvuln(targetId, 'invulnerable')

	getInvulns(targetId) {
		if (!this.invulns[targetId]) {
			this.invulns[targetId] = []
		}

		return this.invulns[targetId]
	}

	_checkInvuln(targetId, type) {
		const currentTimestamp = this.parser.currentTimestamp

		const filtered = this.getInvulns(targetId).filter(invuln =>
			invuln.type === type &&
			invuln.start <= currentTimestamp &&
			invuln.end >= currentTimestamp
		)

		return !!filtered.length
	}
}
